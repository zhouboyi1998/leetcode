<h1 style="text-align: center;"> <span style="color: #00AF9B;">112. è·¯å¾„æ€»å’Œ</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #00AF9B;">**Easy**</span> [**https://leetcode.cn/problems/path-sum/**](https://leetcode.cn/problems/path-sum/)

---

### â“ Description

<br/>

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° `targetSum` ã€‚

åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ **æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ `targetSum` ã€‚

å¦‚æœå­˜åœ¨ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

<img src="../../public/0112/path-sum-1.jpg" alt="path-sum-1.jpg">

```
è¾“å…¥: root = [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1], targetSum = 22
è¾“å‡º: true
è§£é‡Š: ç­‰äºç›®æ ‡å’Œçš„æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹è·¯å¾„å¦‚ä¸Šå›¾æ‰€ç¤º
```

**ç¤ºä¾‹ 2ï¼š**

<img src="../../public/0112/path-sum-2.jpg" alt="path-sum-2.jpg"/>

```
è¾“å…¥: root = [1, 2, 3], targetSum = 5
è¾“å‡º: false
è§£é‡Š: 
    * æ ‘ä¸­å­˜åœ¨ä¸¤æ¡æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„
    * (1 --> 2): å’Œä¸º 3
    * (1 --> 3): å’Œä¸º 4
    * ä¸å­˜åœ¨ sum = 5 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥: root = [], targetSum = 0
è¾“å‡º: false
è§£é‡Š: ç”±äºæ ‘æ˜¯ç©ºçš„, æ‰€ä»¥ä¸å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„
```

<br/>

**æç¤ºï¼š**

* æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®åœ¨èŒƒå›´ `[0, 5000]` å†…
* `-1000 <= Node.val <= 1000`
* `-1000 <= targetSum <= 1000`

---

### â— Solution

<br/>

#### idea

* é¦–å…ˆåˆ¤æ–­ **å½“å‰èŠ‚ç‚¹** æ˜¯å¦ä¸º `null`ï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥è¿”å› `false`

<br/>

* å¦‚æœ **å½“å‰èŠ‚ç‚¹** ä¸ä¸º `null`ï¼Œåˆ¤æ–­ **å½“å‰èŠ‚ç‚¹** æœ‰æ²¡æœ‰ **å­èŠ‚ç‚¹**
* å¦‚æœ **å·¦å³å­èŠ‚ç‚¹** éƒ½ä¸º `null`ï¼Œè¯´æ˜ **å½“å‰èŠ‚ç‚¹** æ˜¯ **å¶å­èŠ‚ç‚¹**
* åˆ¤æ–­ **ç›®æ ‡å€¼** `targetSum` å‡å» **å½“å‰èŠ‚ç‚¹çš„å€¼** `root.val` æ˜¯å¦ä¸º `0`

<br/>

* å¦‚æœä¸º `0` è¯´æ˜ä» **æ ¹èŠ‚ç‚¹** èµ°åˆ° **å½“å‰å¶å­èŠ‚ç‚¹** çš„ **è·¯å¾„æ€»å’Œ** åˆšå¥½ç­‰äº `targetSum`ï¼Œè¿”å› `true`
* å¦‚æœä¸ä¸º `0`ï¼Œè¯´æ˜ **å½“å‰è·¯å¾„** ä¸ç¬¦åˆè¦æ±‚ï¼Œè¿”å› `false`

<br/>

* å¦‚æœ **å½“å‰èŠ‚ç‚¹** ä¸æ˜¯ **å¶å­èŠ‚ç‚¹** ï¼Œå¾€ **å·¦å³å­èŠ‚ç‚¹** åˆ†åˆ«é€’å½’ï¼Œç›´åˆ°æ‰¾åˆ° **å¶å­èŠ‚ç‚¹**
* **é€’å½’** æ—¶å°† **å­èŠ‚ç‚¹** å’Œ `targetSum - root.val` ä¹‹åçš„å€¼ä½œä¸ºå‚æ•°ä¼ é€’ç»™ä¸‹ä¸€çº§

<br/>

* **å·¦å³å­èŠ‚ç‚¹** çš„è·¯å¾„ï¼Œä¼šå„è‡ªè¿”å› **è·¯å¾„æ€»å’Œ** æ˜¯å¦ç­‰äº `targetSum` çš„åˆ¤æ–­
* åªè¦æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹è¿”å› trueï¼Œå½“å‰èŠ‚ç‚¹å°±åº”è¯¥ä¹Ÿè¿”å› true
* æœ€ç»ˆ **é€’å½’** å›åˆ° **æ ¹èŠ‚ç‚¹**ï¼Œ**åªè¦æœ‰ä¸€æ¡è·¯å¾„ä¸Šçš„å¶å­èŠ‚ç‚¹** è¿”å›äº† `true` çš„åˆ¤æ–­ï¼Œæœ€ç»ˆç»“æœå°±æ˜¯ `true`
* å³å¯ä»¥æ‰¾åˆ°ä¸€æ¡ **è·¯å¾„**ï¼Œ**è·¯å¾„æ€»å’Œ** == `targetSum`

<br/>

#### Java

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum - root.val == 0;
        } else {
            return hasPathSum(root.left, targetSum - root.val) || 
                   hasPathSum(root.right, targetSum - root.val);
        }
    }
}
```

<br/>

#### JavaScript

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (root == null) {
        return false
    }
    if (root.left == null && root.right == null) {
        return targetSum - root.val == 0
    } else {
        return hasPathSum(root.left, targetSum - root.val) || 
               hasPathSum(root.right, targetSum - root.val)
    }
};
```

<br/>

#### C#

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public bool HasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum - root.val == 0;
        } else {
            return HasPathSum(root.left, targetSum - root.val) || 
                   HasPathSum(root.right, targetSum - root.val);
        }
    }
}
```

<br/>

#### Scala

```
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def hasPathSum(root: TreeNode, targetSum: Int): Boolean = {
        if (root == null) {
            return false
        }
        if (root.left == null && root.right == null) {
            return targetSum - root.value == 0
        }
        hasPathSum(root.left, targetSum - root.value) || 
        hasPathSum(root.right, targetSum - root.value)
    }
}
```

<br/>

#### Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false;
    }
    if root.Left == nil && root.Right == nil {
        return targetSum - root.Val == 0;
    } else {
        return hasPathSum(root.Left, targetSum - root.Val) || 
               hasPathSum(root.Right, targetSum - root.Val);
    }
}
```

<br/>

#### TypeScript

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function hasPathSum(root: TreeNode | null, targetSum: number): boolean {
    if (root == null) {
            return false
    }
    if (root.left == null && root.right == null) {
        return targetSum - root.val == 0
    } else {
        return hasPathSum(root.left, targetSum - root.val) || 
               hasPathSum(root.right, targetSum - root.val)
    }
};
```

<br/>

#### Kotlin

```
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun hasPathSum(root: TreeNode?, targetSum: Int): Boolean {
        if (root == null) {
            return false
        }
        if (root.left == null && root.right == null) {
            return targetSum - root.`val` == 0
        } else {
            return hasPathSum(root.left, targetSum - root.`val`) || 
                   hasPathSum(root.right, targetSum - root.`val`)
        }
    }
}
```
