<h1 style="text-align: center;"> <span style="color: #00AF9B;">21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #00AF9B;">**Easy**</span> [**https://leetcode.cn/problems/merge-two-sorted-lists/**](https://leetcode.cn/problems/merge-two-sorted-lists/)

---

### â“ Description

<br/>

å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ **å‡åº** é“¾è¡¨å¹¶è¿”å›ã€‚

æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

<img src="../../public/0021/merge-two-sorted-lists-1.jpg" alt="merge-two-sorted-lists-1.jpg"/>

```
è¾“å…¥: l1 = [1, 2, 4], l2 = [1, 3, 4]
è¾“å‡º: [1, 1, 2, 3, 4, 4]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: l1 = [], l2 = []
è¾“å‡º: []
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥: l1 = [], l2 = [0]
è¾“å‡º: [0]
```

<br/>

**æç¤ºï¼š**

* ä¸¤ä¸ªé“¾è¡¨çš„èŠ‚ç‚¹æ•°ç›®èŒƒå›´æ˜¯ `[0, 50]`
* `-100 <= Node.val <= 100`
* `l1` å’Œ `l2` å‡æŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—

---

### â— Solution

<br/>

#### idea

* æ–°å»ºä¸€ä¸ª `current` èŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªæ–°çš„é“¾è¡¨
* æ–°å»ºä¸€ä¸ª `head` èŠ‚ç‚¹ä¿å­˜é“¾è¡¨è¡¨å¤´çš„ä½ç½®ï¼Œæ–¹ä¾¿è¿”å›

<br/>

* åŒæ—¶éå† `list1` å’Œ `list2` ä¸¤ä¸ªé“¾è¡¨
* æ¯”è¾ƒé“¾è¡¨èŠ‚ç‚¹ä¸Šå€¼çš„å¤§å°ï¼Œå°†å€¼æ›´å°çš„èŠ‚ç‚¹ä¿å­˜åˆ°æ–°é“¾è¡¨ä¸­
* æœ€åå°†é“¾è¡¨è¿”å›

<br/>

#### C

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
    struct ListNode* current = (struct ListNode*) malloc(sizeof(struct ListNode));
    struct ListNode* head = current;
    while (list1 != NULL && list2 != NULL) {
        if (list1->val < list2->val) {
            current->next = list1;
            list1 = list1->next;
        } else {
            current->next = list2;
            list2 = list2->next;
        }
        current = current->next;
    }
    current->next = list1 == NULL ? list2 : list1;
    return head->next;
}
```

<br/>

#### C++

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* current = new ListNode();
        ListNode* head = current;
        while (list1 != NULL && list2 != NULL) {
            if (list1->val < list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }
        current->next = list1 == NULL ? list2 : list1;
        return head->next;
    }
};
```

<br/>

#### Java

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode current = new ListNode();
        ListNode head = current;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        current.next = list1 == null ? list2 : list1;
        return head.next;
    }
}

```

<br/>

#### JavaScript

```
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let current = new ListNode()
    let head = current
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            current.next = list1
            list1 = list1.next
        } else {
            current.next = list2
            list2 = list2.next
        }
        current = current.next
    }
    current.next = list1 == null ? list2 : list1
    return head.next
};
```

<br/>

#### C#

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution {
    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {
        ListNode current = new ListNode();
        ListNode head = current;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        current.next = list1 == null ? list2 : list1;
        return head.next;
    }
}
```

<br/>

#### Go

```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    current := &ListNode{};
    head := current;
    for {
        if list1 == nil || list2 == nil {
            break;
        }
        if list1.Val < list2.Val {
            current.Next = list1;
            list1 = list1.Next;
        } else {
            current.Next = list2;
            list2 = list2.Next;
        }
        current = current.Next;
    }
    if list1 == nil {
        current.Next = list2;
    } else {
        current.Next = list1;
    }
    return head.Next;
}
```

<br/>

#### Dart

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *   int val;
 *   ListNode? next;
 *   ListNode([this.val = 0, this.next]);
 * }
 */
class Solution {
    ListNode? mergeTwoLists(ListNode? list1, ListNode? list2) {
        ListNode? current = new ListNode();
        ListNode? head = current;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                current?.next = list1;
                list1 = list1.next;
            } else {
                current?.next = list2;
                list2 = list2.next;
            }
            current = current?.next;
        }
        current?.next = list1 == null ? list2 : list1;
        return head.next;
    }
}
```

<br/>

#### TypeScript

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    let current: ListNode = new ListNode()
    let head = current
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            current.next = list1
            list1 = list1.next
        } else {
            current.next = list2
            list2 = list2.next
        }
        current = current.next
    }
    current.next = list1 == null ? list2 : list1
    return head.next
};
```

<br/>

#### Kotlin

```
/**
 * Example:
 * var li = ListNode(5)
 * var v = li.`val`
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int) {
 *     var next: ListNode? = null
 * }
 */
class Solution {
    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {
        var l1 = list1
        var l2 = list2
        var current: ListNode? = ListNode(-1)
        var head = current
        while (l1 != null && l2 != null) {
            if (l1.`val` < l2.`val`) {
                current?.next = l1
                l1 = l1.next
            } else {
                current?.next = l2
                l2 = l2.next
            }
            current = current?.next
        }
        if (l1 == null) {
            current?.next = l2
        } else {
            current?.next = l1
        }
        return head?.next
    }
}
```
