<h1 style="text-align: center;"> <span style="color: #00AF9B;">2236. åˆ¤æ–­æ ¹ç»“ç‚¹æ˜¯å¦ç­‰äºå­ç»“ç‚¹ä¹‹å’Œ</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #00AF9B;">**Easy**</span> [**https://leetcode.cn/problems/root-equals-sum-of-children/**](https://leetcode.cn/problems/root-equals-sum-of-children/)

---

### â“ Description

<br/>

ç»™ä½ ä¸€ä¸ª **äºŒå‰æ ‘** çš„æ ¹ç»“ç‚¹ `root`ï¼Œè¯¥äºŒå‰æ ‘ç”±æ°å¥½ `3` ä¸ªç»“ç‚¹ç»„æˆï¼šæ ¹ç»“ç‚¹ã€å·¦å­ç»“ç‚¹å’Œå³å­ç»“ç‚¹ã€‚

å¦‚æœæ ¹ç»“ç‚¹å€¼ç­‰äºä¸¤ä¸ªå­ç»“ç‚¹å€¼ä¹‹å’Œï¼Œè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

<img src="../../public/2236/root-equals-sum-of-children-1.png" alt="root-equals-sum-of-children-1.png"/>

```
è¾“å…¥: root = [10, 4, 6]
è¾“å‡º: true
è§£é‡Š: 
    * æ ¹ç»“ç‚¹ã€å·¦å­ç»“ç‚¹å’Œå³å­ç»“ç‚¹çš„å€¼åˆ†åˆ«æ˜¯ 10 ã€4 å’Œ 6
    * ç”±äº 10 ç­‰äº 4 + 6, å› æ­¤è¿”å› true
```

**ç¤ºä¾‹ 2ï¼š**

<img src="../../public/2236/root-equals-sum-of-children-2.png" alt="root-equals-sum-of-children-2.png"/>

```
è¾“å…¥: root = [5, 3, 1]
è¾“å‡º: false
è§£é‡Š: 
    * æ ¹ç»“ç‚¹ã€å·¦å­ç»“ç‚¹å’Œå³å­ç»“ç‚¹çš„å€¼åˆ†åˆ«æ˜¯ 5 ã€3 å’Œ 1
    * ç”±äº 5 ä¸ç­‰äº 3 + 1, å› æ­¤è¿”å› false
```

<br/>

**æç¤ºï¼š**

* æ ‘åªåŒ…å«æ ¹ç»“ç‚¹ã€å·¦å­ç»“ç‚¹å’Œå³å­ç»“ç‚¹
* `-100 <= Node.val <= 100`

---

### â— Solution

<br/>

ğŸ…° â– â– â– â– â– ğŸ…± â“

<br/>

#### Java

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean checkTree(TreeNode root) {
        return root.val == root.left.val + root.right.val;
    }
}
```

<br/>

#### Rust

```
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        return 
            root.as_ref().unwrap().borrow().val == 
            root.as_ref().unwrap().borrow().left.as_ref().unwrap().borrow().val + 
            root.as_ref().unwrap().borrow().right.as_ref().unwrap().borrow().val;
    }
}
```
