<h1 style="text-align: center;"> <span style="color: #00AF9B;">100. ç›¸åŒçš„æ ‘</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #00AF9B;">**Easy**</span> [**https://leetcode.cn/problems/same-tree/**](https://leetcode.cn/problems/same-tree/)

---

### â“ Description

<br/>

ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `p` å’Œ `q` ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚

å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

<img src="../../public/0100/same-tree-1.jpg" alt="same-tree-1.jpg"/>

```
è¾“å…¥: p = [1, 2, 3], q = [1, 2, 3]
è¾“å‡º: true
```

**ç¤ºä¾‹ 2ï¼š**

<img src="../../public/0100/same-tree-2.jpg" alt="same-tree-2.jpg"/>

```
è¾“å…¥: p = [1, 2], q = [1, null, 2]
è¾“å‡º: false
```

**ç¤ºä¾‹ 3ï¼š**

<img src="../../public/0100/same-tree-3.jpg" alt="same-tree-3.jpg"/>

```
è¾“å…¥: p = [1, 2, 1], q = [1, 1, 2]
è¾“å‡º: false
```

<br/>

**æç¤ºï¼š**

* ä¸¤æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹æ•°ç›®éƒ½åœ¨èŒƒå›´ `[0, 100]` å†…
* `-10^4 <= Node.val <= 10^4`

---

### â— Solution

<br/>

#### idea

* `p` å’Œ `q` ä»£è¡¨ä¸¤æ£µæ ‘ **ç›¸åŒä½ç½®ä¸Šçš„ä¸¤ä¸ªèŠ‚ç‚¹**

<br/>

* `p` å’Œ `q` éƒ½ä¸º `null` æ—¶ï¼Œä¸¤ä¸ªèŠ‚ç‚¹ç›¸åŒï¼Œè¿”å› `true`
* æ’é™¤éƒ½ä¸º `null` çš„æƒ…å†µåï¼Œå¦‚æœ `p` æˆ– `q` ä»ç„¶æœ‰ä¸€ä¸ªä¸º `null`
* è¯´æ˜ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªä¸º `null`ï¼Œä¸€ä¸ªä¸ä¸º `null`ï¼Œè¿”å› `false`

<br/>

* ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ä¸º `null` æ—¶ï¼Œåˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸ç­‰
* å¦‚æœå€¼ä¸ç›¸ç­‰ï¼Œè¿”å› `false`

<br/>

* ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ä¸º `null`ï¼Œä¸”å€¼ç›¸ç­‰
* é€’å½’è°ƒç”¨ï¼Œåˆ†åˆ«å¯¹ **å·¦å³å­æ ‘ä¸Šçš„èŠ‚ç‚¹** è¿›è¡Œåˆ¤æ–­
* å½“ **å·¦å³å­æ ‘** æ˜¯å¦ç›¸åŒçš„åˆ¤æ–­éƒ½è¿”å› `true` æ—¶ï¼Œ**å½“å‰èŠ‚ç‚¹** ä¹Ÿè¿”å› `true`

<br/>

#### C

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if (p == NULL && q == NULL) {
        return true;
    }
    if (p == NULL || q == NULL) {
        return false;
    }
    if (p->val != q->val) {
        return false;
    } else {
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
}
```

<br/>

#### C++

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL && q == NULL) {
            return true;
        }
        if (p == NULL || q == NULL) {
            return false;
        }
        if (p->val != q->val) {
            return false;
        } else {
            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
        }
    }
};
```

<br/>

#### Ruby

```
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} p
# @param {TreeNode} q
# @return {Boolean}
def is_same_tree(p, q)
    if (p == nil && q == nil)
        return true
    end
    if (p == nil || q == nil)
        return false
    end
    if (p.val != q.val) 
        return false
    else
        return is_same_tree(p.left, q.left) && is_same_tree(p.right, q.right)
    end
end
```

<br/>

#### Java

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        if (p.val != q.val) {
            return false;
        } else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
```

<br/>

#### JavaScript

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if (p == null && q == null) {
        return true
    }
    if (p == null || q == null) {
        return false
    }
    if (p.val != q.val) {
        return false
    } else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
};
```

<br/>

#### PHP

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {
    /**
     * @param TreeNode $p
     * @param TreeNode $q
     * @return Boolean
     */
    function isSameTree($p, $q) {
        if ($p == null && $q == null) {
            return true;
        }
        if ($p == null || $q == null) {
            return false;
        }
        if ($p->val != $q->val) {
            return false;
        } else {
            return $this->isSameTree($p->left, $q->left) && $this->isSameTree($p->right, $q->right);
        }
    }
}
```

<br/>

#### C#

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public bool IsSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        if (p.val != q.val) {
            return false;
        } else {
            return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);
        }
    }
}
```

<br/>

#### Scala

```
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        if (p == null && q == null) {
            return true
        }
        if (p == null || q == null) {
            return false
        }
        if (p.value != q.value) {
            return false
        }
        isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
}
```

<br/>

#### Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil {
        return true;
    }
    if p == nil || q == nil {
        return false;
    }
    if p.Val != q.Val {
        return false;
    } else {
        return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right);
    }
}
```

<br/>

#### Dart

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   int val;
 *   TreeNode? left;
 *   TreeNode? right;
 *   TreeNode([this.val = 0, this.left, this.right]);
 * }
 */
class Solution {
    bool isSameTree(TreeNode? p, TreeNode? q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        if (p.val != q.val) {
            return false;
        } else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
```

<br/>

#### TypeScript

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {
    if (p == null && q == null) {
        return true
    }
    if (p == null || q == null) {
        return false
    }
    if (p.val != q.val) {
        return false
    } else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
};
```

<br/>

#### Swift

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {
        if (p == nil && q == nil) {
            return true;
        }
        if (p == nil || q == nil) {
            return false;
        }
        if (p?.val != q?.val) {
            return false;
        } else {
            return isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right);
        }
    }
}
```

<br/>

#### Kotlin

```
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {
        if (p == null && q == null) {
            return true
        }
        if (p == null || q == null) {
            return false
        }
        if (p.`val` != q.`val`) {
            return false
        } else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        }
    }
}
```
