<h1 style="text-align: center;"> <span style="color: #00AF9B;">169. å¤šæ•°å…ƒç´ </span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #00AF9B;">**Easy**</span> [**https://leetcode.cn/problems/majority-element/**](https://leetcode.cn/problems/majority-element/)

---

### â“ Description

<br/>

ç»™å®šä¸€ä¸ªå¤§å°ä¸º `n` çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ä¸­çš„å¤šæ•°å…ƒç´ ã€‚

å¤šæ•°å…ƒç´ æ˜¯æŒ‡åœ¨æ•°ç»„ä¸­å‡ºç°æ¬¡æ•° **å¤§äº** `âŒŠ n/2 âŒ‹` çš„å…ƒç´ ã€‚

ä½ å¯ä»¥å‡è®¾æ•°ç»„æ˜¯éç©ºçš„ï¼Œå¹¶ä¸”ç»™å®šçš„æ•°ç»„æ€»æ˜¯å­˜åœ¨å¤šæ•°å…ƒç´ ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥: nums = [3, 2, 3]
è¾“å‡º: 3
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: nums = [2, 2, 1, 1, 1, 2, 2]
è¾“å‡º: 2
```

<br/>

**æç¤ºï¼š**

* `n == nums.length`
* `1 <= n <= 5 * 10^4`
* `-10^9 <= nums[i] <= 10^9`

<br/>

**è¿›é˜¶ï¼š** å°è¯•è®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º `O(n)`ã€ç©ºé—´å¤æ‚åº¦ä¸º `O(1)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚

---

### â— Solution

<br/>

#### idea

* ä½¿ç”¨ <span style="color: #AF52DE;">**å“ˆå¸Œè¡¨**</span> è§£å†³é—®é¢˜
* éå†æ•°ç»„ï¼Œä»¥æ•°ç»„å…ƒç´ ä½œä¸º `key`ï¼Œå…ƒç´ å‡ºç°æ¬¡æ•°ä½œä¸º `value` æ„å»º **å“ˆå¸Œè¡¨**
* éå† **å“ˆå¸Œè¡¨**ï¼Œæ¯”è¾ƒ `value` çš„å¤§å°ï¼Œè¿”å› `value` æœ€å¤§çš„ `key`

<br/>

* æ—¶é—´å¤æ‚åº¦ï¼š`O(n)`
* ç©ºé—´å¤æ‚åº¦ï¼š`O(n)`

<br/>

#### C++

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> map;
        for (int num : nums) {
            map[num]++;
        }
        int k;
        int v = -1;
        for (auto [key, value] : map) {
            if (value > v) {
                k = key;
                v = value;
            }
        }
        return k;
    }
};
```

<br/>

#### Java

```
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int num : nums) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        Map.Entry<Integer, Integer> result = null;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            if (result == null || entry.getValue() > result.getValue()) {
                result = entry;
            }
        }
        return result.getKey();
    }
}
```

<br/>

#### Go

```
func majorityElement(nums []int) int {
    hash := make(map[int]int, len(nums));
    for _, num := range nums {
        value, ok := hash[num];
        if ok {
            hash[num] = value + 1;
        } else {
            hash[num] = 1;
        }
    }
    var k int;
    v := -1;
    for key, value := range hash {
        if value > v {
            k = key;
            v = value;
        }
    }
    return k;
}
```

<br/>

#### Rust

```
impl Solution {
    pub fn majority_element(nums: Vec<i32>) -> i32 {
        let mut map: std::collections::HashMap<i32, i32> = std::collections::HashMap::new();
        for num in nums.iter() {
            let value = map.entry(*num).or_insert(0);
            *value += 1;
        }
        let mut k: i32 = 0;
        let mut v: i32 = -1;
        for (&key, &value) in map.iter() {
            if value > v {
                k = key;
                v = value;
            }
        }
        return k;
    }
}
```
