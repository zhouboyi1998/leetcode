<h1 style="text-align: center;"> <span style="color: #FFB822;">é¢è¯•é¢˜ 17.11. å•è¯è·ç¦»</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #FFB822;">**Medium**</span> [**https://leetcode.cn/problems/find-closest-lcci/**](https://leetcode.cn/problems/find-closest-lcci/)

---

### â“ Description

<br/>

æœ‰ä¸ªå†…å«å•è¯çš„è¶…å¤§æ–‡æœ¬æ–‡ä»¶ï¼Œç»™å®šä»»æ„ä¸¤ä¸ª **ä¸åŒçš„** å•è¯ï¼Œæ‰¾å‡ºåœ¨è¿™ä¸ªæ–‡ä»¶ä¸­è¿™ä¸¤ä¸ªå•è¯çš„æœ€çŸ­è·ç¦»ï¼ˆç›¸éš”å•è¯æ•°ï¼‰ã€‚

å¦‚æœå¯»æ‰¾è¿‡ç¨‹åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ä¼šé‡å¤å¤šæ¬¡ï¼Œè€Œæ¯æ¬¡å¯»æ‰¾çš„å•è¯ä¸åŒï¼Œä½ èƒ½å¯¹æ­¤ä¼˜åŒ–å—ï¼Ÿ

<br/>

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥: 
    * words = ["I", "am", "a", "student", "from", "a", "university", "in", "a", "city"]
    * word1 = "a"
    * word2 = "student"
è¾“å‡º: 1
```

<br/>

**æç¤ºï¼š**

* `words.length <= 100000`

---

### â— Solution

<br/>

#### idea

* éå†æ•°ç»„ï¼Œè®°å½• `word1` å’Œ `word2` å‡ºç°æ—¶çš„ä¸‹æ ‡
* å½“ **ä¸¤ä¸ªå•è¯** éƒ½å‡ºç°è¿‡ä¸€æ¬¡å
* å°†ç»“æœæ›¿æ¢æˆ **å½“å‰ä¸¤ä¸ªä¸‹æ ‡çš„è·ç¦»** å’Œ **å½“å‰ç»“æœ** ä¸­æ›´å°çš„å€¼

<br/>

#### Java

```
class Solution {
    public int findClosest(String[] words, String word1, String word2) {
        int len = words.length;
        int result = len;
        int index1 = -1;
        int index2 = -1;
        for (int i = 0; i < len; i++) {
            if (words[i].equals(word1)) {
                index1 = i;
            } else if (words[i].equals(word2)) {
                index2 = i;
            }
            if (index1 > 0 && index2 > 0) {
                result = Math.min(result, Math.abs(index1 - index2));
            }
        }
        return result;
    }
}
```

<br/>

#### Go

```
func findClosest(words []string, word1 string, word2 string) int {
    result := len(words);
    index1 := -1;
    index2 := -1;
    for i, x := range words {
        if strings.Compare(x, word1) == 0 {
            index1 = i;
        } else if strings.Compare(x, word2) == 0 {
            index2 = i;
        }
        if index1 > 0 && index2 > 0 {
            result = int(math.Min(float64(result), math.Abs(float64(index1 - index2))));
        }
    }
    return result;
}
```

<br/>

#### Rust

```
impl Solution {
    pub fn find_closest(words: Vec<String>, word1: String, word2: String) -> i32 {
        let mut result: i32 = words.len() as i32;
        let mut index1: i32 = -1;
        let mut index2: i32 = -1;
        for (i, x) in words.iter().enumerate() {
            if x == &word1 {
                index1 = i as i32;
            } else if x == &word2 {
                index2 = i as i32;
            }
            if index1 > 0 && index2 > 0 {
                result = i32::min(result, i32::abs(index1 - index2));
            }
        }
        return result;
    }
}
```
