<h1 style="text-align: center;"> <span style="color: #FFB822;">114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #FFB822;">**Medium**</span> [**https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/**](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

---

### â“ Description

<br/>

ç»™ä½ äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ `root` ï¼Œè¯·ä½ å°†å®ƒå±•å¼€ä¸ºä¸€ä¸ªå•é“¾è¡¨ï¼š

* å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥åŒæ ·ä½¿ç”¨ `TreeNode` ï¼Œå…¶ä¸­ `right` å­æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè€Œå·¦å­æŒ‡é’ˆå§‹ç»ˆä¸º `null` ã€‚
* å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥ä¸äºŒå‰æ ‘ [**å…ˆåºéå†**](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839) é¡ºåºç›¸åŒã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

<img src="../../public/0114/flatten-binary-tree-linked-list-1.jpg" alt="flatten-binary-tree-linked-list-1.jpg"/>

```
è¾“å…¥: root = [1, 2, 5, 3, 4, null, 6]
è¾“å‡º: [1, null, 2, null, 3, null, 4, null, 5, null, 6]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: root = []
è¾“å‡º: []
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥: root = [0]
è¾“å‡º: [0]
```

<br/>

**æç¤ºï¼š**

* æ ‘ä¸­ç»“ç‚¹æ•°åœ¨èŒƒå›´ `[0, 2000]` å†…
* `-100 <= Node.val <= 100`

<br/>

**è¿›é˜¶ï¼š** ä½ å¯ä»¥ä½¿ç”¨ [**åŸåœ°ç®—æ³•**](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) ï¼ˆ`O(1)` é¢å¤–ç©ºé—´ï¼‰å±•å¼€è¿™æ£µæ ‘å—ï¼Ÿ

---

### â— Solution

<br/>

#### idea

* å¦‚æœ **å½“å‰èŠ‚ç‚¹** ä¸º `null`ï¼Œç›´æ¥è¿”å›
* å¦‚æœ **å½“å‰èŠ‚ç‚¹** ä¸ä¸º `null`ï¼Œå¯¹ **å·¦å³å­æ ‘** éƒ½è¿›è¡Œé€’å½’ï¼Œç›´åˆ°æ‰¾åˆ° **å¶å­èŠ‚ç‚¹**
* **å¶å­èŠ‚ç‚¹** çš„ **å·¦å³å­èŠ‚ç‚¹** éƒ½ä¸º `null`ï¼Œä¹Ÿä¼šç›´æ¥è¿”å›
* ç„¶åæˆ‘ä»¬ä» **å¶å­èŠ‚ç‚¹çš„ä¸Šä¸€å±‚** å¼€å§‹å¤„ç†æ•°æ®

<br/>

* æ–°å»ºä¸€ä¸ª `TreeNode` å˜é‡ä¸´æ—¶å­˜å‚¨ **å³å­èŠ‚ç‚¹**
* å°† **å½“å‰èŠ‚ç‚¹** çš„ **å·¦å­èŠ‚ç‚¹** ç§»åˆ°å³è¾¹ï¼Œä½œä¸º **æ–°çš„å³å­èŠ‚ç‚¹**
* å†å°† **æ—§çš„å³å­èŠ‚ç‚¹** æ‹¼æ¥åˆ° **æ–°çš„å³å­èŠ‚ç‚¹** çš„æœ«å°¾

<br/>

* æ³¨æ„ï¼šéœ€è¦å°† **æ—§çš„å³å­èŠ‚ç‚¹** æ‹¼æ¥åˆ° **æ–°çš„å³å­èŠ‚ç‚¹** çš„æœ«å°¾
* å¦‚æœæ­¤æ—¶ **å½“å‰èŠ‚ç‚¹** çš„ **å­æ ‘** å·²ç»ä¸æ­¢ä¸€å±‚
* æˆ‘ä»¬å°±éœ€è¦é€’å½’å¯»æ‰¾å®ƒ **æ–°çš„å³å­èŠ‚ç‚¹** çš„æœ«å°¾ï¼Œå†å°†è¿›è¡Œæ‹¼æ¥

<br/>

* å› ä¸ºé€’å½’è°ƒç”¨æ˜¯åœ¨å¤„ç†é€»è¾‘ä¹‹å‰
* å¤„ç† **å½“å‰èŠ‚ç‚¹** æ—¶ï¼Œå®ƒçš„ **å·¦å³å­æ ‘** è‚¯å®šæ˜¯å·²ç»å¤„ç†å®Œæ¯•çš„äº†
* æ‰€ä»¥é€’å½’å¯»æ‰¾æœ«å°¾æ—¶ï¼Œåªéœ€è¦ä¸€ç›´å¾€ **å³å­èŠ‚ç‚¹** æ–¹å‘å¯»æ‰¾å³å¯

<br/>

#### C

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
void flatten(struct TreeNode* root) {
    if (root == NULL) {
        return;
    }
    if (root->left == NULL && root->right == NULL) {
        return;
    }
    flatten(root->left);
    flatten(root->right);
    struct TreeNode* temp = root->right;
    root->right = root->left;
    root->left = NULL;
    while (root->right != NULL) {
        root = root->right;
    }
    root->right = temp;
}
```

<br/>

#### C++

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        if (root->left == NULL && root->right == NULL) {
            return;
        }
        flatten(root->left);
        flatten(root->right);
        TreeNode* temp = root->right;
        root->right = root->left;
        root->left = NULL;
        while (root->right != NULL) {
            root = root->right;
        }
        root->right = temp;
    }
};
```

<br/>

#### Ruby

```
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Void} Do not return anything, modify root in-place instead.
def flatten(root)
    if (root == nil)
        return
    end
    if (root.left == nil && root.right == nil)
        return
    end
    flatten(root.left)
    flatten(root.right)
    @temp = root.right
    root.right = root.left
    root.left = nil
    while (root.right != nil)
        root = root.right
    end
    root.right = @temp
end
```

<br/>

#### Java

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) {
            return;
        }
        flatten(root.left);
        flatten(root.right);
        TreeNode temp = root.right;
        root.right = root.left;
        root.left = null;
        while (root.right != null) {
            root = root.right;
        }
        root.right = temp;
    }
}
```

<br/>

#### JavaScript

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    if (root == null) {
        return;
    }
    if (root.left == null && root.right == null) {
        return;
    }
    flatten(root.left);
    flatten(root.right);
    let temp = root.right;
    root.right = root.left;
    root.left = null;
    while (root.right != null) {
        root = root.right;
    }
    root.right = temp;
};
```

<br/>

#### PHP

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {
    /**
     * @param TreeNode $root
     * @return NULL
     */
    function flatten($root) {
        if ($root == NULL) {
            return;
        }
        if ($root->left == NULL && $root->right == NULL) {
            return;
        }
        $this->flatten($root->left);
        $this->flatten($root->right);
        $temp = $root->right;
        $root->right = $root->left;
        $root->left = NULL;
        while ($root->right != NULL) {
            $root = $root->right;
        }
        $root->right = $temp;
    }
}
```

<br/>

#### C#

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public void Flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) {
            return;
        }
        Flatten(root.left);
        Flatten(root.right);
        TreeNode temp = root.right;
        root.right = root.left;
        root.left = null;
        while (root.right != null) {
            root = root.right;
        }
        root.right = temp;
    }
}
```

<br/>

#### Scala

```
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def flatten(root: TreeNode): Unit = {
        if (root == null) {
            return
        }
        if (root.left == null && root.right == null) {
            return
        }
        flatten(root.left)
        flatten(root.right)
        var temp: TreeNode = root.right
        root.right = root.left
        root.left = null
        var node: TreeNode = catenate(root)
        node.right = temp
    }

    def catenate(node: TreeNode): TreeNode = {
        if (node.right != null) {
            return catenate(node.right)
        }
        node
    }
}
```

<br/>

#### Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func flatten(root *TreeNode)  {
    if root == nil {
        return;
    }
    if root.Left == nil && root.Right == nil {
        return;
    }
    flatten(root.Left);
    flatten(root.Right);
    temp := root.Right;
    root.Right = root.Left;
    root.Left = nil;
    for {
        if root.Right == nil {
            break;
        }
        root = root.Right;
    }
    root.Right = temp;
}
```

<br/>

#### Dart

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   int val;
 *   TreeNode? left;
 *   TreeNode? right;
 *   TreeNode([this.val = 0, this.left, this.right]);
 * }
 */
class Solution {
    void flatten(TreeNode? root) {
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) {
            return;
        }
        flatten(root.left);
        flatten(root.right);
        TreeNode? temp = root.right;
        root.right = root.left;
        root.left = null;
        while (root?.right != null) {
            root = root?.right;
        }
        root?.right = temp;
    }
}
```

<br/>

#### TypeScript

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
/**
 Do not return anything, modify root in-place instead.
 */
function flatten(root: TreeNode | null): void {
    if (root == null) {
        return;
    }
    if (root.left == null && root.right == null) {
        return;
    }
    flatten(root.left);
    flatten(root.right);
    let temp: TreeNode | null = root.right;
    root.right = root.left;
    root.left = null;
    while (root.right != null) {
        root = root.right;
    }
    root.right = temp;
};
```

<br/>

#### Kotlin

```
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun flatten(root: TreeNode?): Unit {
        if (root == null) {
            return
        }
        if (root.left == null && root.right == null) {
            return
        }
        flatten(root.left)
        flatten(root.right)
        var temp: TreeNode? = root.right
        root.right = root.left
        root.left = null
        var node: TreeNode = catenate(root)
        node.right = temp
    }

    fun catenate(node: TreeNode): TreeNode {
        if (node.right != null) {
            return catenate(node.right)
        } else {
            return node
        }
    }
}
```
