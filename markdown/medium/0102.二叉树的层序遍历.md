<h1 style="text-align: center;"> <span style="color: #FFB822;">102. äºŒå‰æ ‘çš„å±‚åºéå†</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #FFB822;">**Medium**</span> [**https://leetcode.cn/problems/binary-tree-level-order-traversal/**](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

---

### â“ Description

<br/>

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†**ã€‚ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

<img src="../../public/0102/tree-1.jpg" alt="tree-1.jpg"/>

```
è¾“å…¥ï¼šroot = [3, 9, 20, null, null, 15, 7]
è¾“å‡ºï¼š[[3], [9, 20], [15, 7]]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: root = [1]
è¾“å‡º: [[1]]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥: root = []
è¾“å‡º: []
```

<br/>

**æç¤ºï¼š**

* æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
* `-1000 <= Node.val <= 1000`

---

### â— Solution

<br/>

#### Java

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<>();
        }

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> item = new ArrayList<>();

        // åˆ©ç”¨é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºçš„ç‰¹ç‚¹, å­˜å‚¨ä¸‹ä¸€å±‚æ ‘èŠ‚ç‚¹
        // å½“éå†å®Œå½“å‰å±‚çš„æ ‘èŠ‚ç‚¹, å°†ä¸‹ä¸€å±‚çš„æ ‘èŠ‚ç‚¹ä¾æ¬¡å–å‡ºè¿›è¡Œæ“ä½œ
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        // å½“å‰å±‚çº§çš„æœ€å¤§èŠ‚ç‚¹æ•°
        int maxNum = 1;
        // ä¸‹ä¸€å±‚çº§çš„æœ€å¤§èŠ‚ç‚¹æ•°éœ€è¦æ‰£å‡çš„æ•°é‡
        int subNum = 0;
        // å½“å‰å±‚çº§å·²æ·»åŠ çš„èŠ‚ç‚¹æ•°
        int curNum = 0;

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node != null) {
                item.add(node.val);
                queue.add(node.left);
                queue.add(node.right);
            } else {
                // å½“å‰å±‚çº§æ¯æœ‰ 1 ä¸ªèŠ‚ç‚¹ä¸º null, ä¸‹ä¸€å±‚çº§çš„æœ€å¤§èŠ‚ç‚¹æ•°å°±éœ€è¦ - 2
                subNum += 2;
            }
            // å½“å‰å±‚çº§å·²æ·»åŠ çš„èŠ‚ç‚¹æ•° + 1
            curNum++;
            // å¦‚æœå½“å‰å±‚çº§å·²æ·»åŠ çš„èŠ‚ç‚¹æ•° = å½“å‰å±‚çº§çš„æœ€å¤§èŠ‚ç‚¹æ•°, åˆ‡æ¢åˆ°ä¸‹ä¸€å±‚çº§
            if (curNum == maxNum) {
                // å¦‚æœå½“å‰å±‚çº§æœ‰èŠ‚ç‚¹, æ·»åŠ åˆ°ç»“æœä¸­
                if (item.size() > 0) {
                    result.add(item);
                }
                // é‡ç½®å„é¡¹æ ‡å¿—
                item = new ArrayList<>();
                maxNum = maxNum * 2 - subNum;
                subNum = 0;
                curNum = 0;
            }
        }

        return result;
    }
}
```
