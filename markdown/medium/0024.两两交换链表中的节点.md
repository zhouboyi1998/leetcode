<h1 style="text-align: center;"> <span style="color: #FFB822;">24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹</span> </h1>

### ğŸš€ LeetCode

<base target="_blank">

<span style="color: #FFB822;">**Medium**</span> [**https://leetcode.cn/problems/swap-nodes-in-pairs/**](https://leetcode.cn/problems/swap-nodes-in-pairs/)

---

### â“ Description

<br/>

ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚

ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚

<br/>

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥: head = [1, 2, 3, 4]
è¾“å‡º: [2, 1, 4, 3]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: head = []
è¾“å‡º: []
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥: head = [1]
è¾“å‡º: [1]
```

<br/>

**æç¤ºï¼š**

* é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
* `0 <= Node.val <= 100`

---

### â— Solution

<br/>

#### idea

* ç”±äº `head` å…¶å®æ˜¯é“¾è¡¨çš„ **ç¬¬ä¸€ä¸ªèŠ‚ç‚¹** è€Œä¸æ˜¯ **å¤´èŠ‚ç‚¹**
* è€Œåç»­çš„æ“ä½œä¸­ **ç¬¬ä¸€ä¸ªèŠ‚ç‚¹** è¦å’Œ **ç¬¬äºŒä¸ªèŠ‚ç‚¹** è¿›è¡Œäº¤æ¢
* äº¤æ¢è¿‡å `head` æŒ‡å‘çš„å°±ä¸æ˜¯é“¾è¡¨çš„ **ç¬¬ä¸€ä¸ªèŠ‚ç‚¹** äº†ï¼Œè€Œæ˜¯ **ç¬¬äºŒä¸ªèŠ‚ç‚¹**
* æ‰€ä»¥éœ€è¦æ–°å»ºä¸€ä¸ª **å¤´èŠ‚ç‚¹** `result` æŒ‡å‘ `head` çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
* `result` åé¢è·Ÿç€çš„å°±æ˜¯éœ€è¦è¿”å›çš„é“¾è¡¨

<br/>

* äº¤æ¢é“¾è¡¨èŠ‚ç‚¹ä¹Ÿéœ€è¦ä» **å¤´èŠ‚ç‚¹** å¼€å§‹
* å› ä¸ºéœ€è¦è®°å½• **å½“å‰æ“ä½œèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹**ï¼Œç”¨äºäº¤æ¢èŠ‚ç‚¹åå†å°†é“¾è¡¨è¿æ¥èµ·æ¥
* å†æ–°å»ºä¸€ä¸ª **å¤´èŠ‚ç‚¹** `previous` æŒ‡å‘ `head` çš„å‰ä¸€ä¸ªèŠ‚ç‚¹

<br/>

* ä»¥ **æ­¥é•¿** `2` éå†é“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢èŠ‚ç‚¹
* å½“ `previous` èŠ‚ç‚¹çš„åä¸¤ä¸ªèŠ‚ç‚¹å­˜åœ¨ `null` æ—¶ç»“æŸå¾ªç¯
* è¿”å› **å¤´èŠ‚ç‚¹** `result` çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹

<br/>

#### C

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* swapPairs(struct ListNode* head) {
    struct ListNode result = {0, head};
    struct ListNode* previous = &result;
    while (previous->next != NULL && 
    previous->next->next != NULL) {
        struct ListNode* temp = previous->next->next;
        previous->next->next = previous->next->next->next;
        temp->next = previous->next;
        previous->next = temp;
        previous = previous->next->next;
    }
    return result.next;
}
```

<br/>

#### C++

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* result = new ListNode(0, head);
        ListNode* previous = result;
        while (previous->next != NULL && previous->next->next != NULL) {
            ListNode* temp = previous->next->next;
            previous->next->next = previous->next->next->next;
            temp->next = previous->next;
            previous->next = temp;
            previous = previous->next->next;
        }
        return result->next;
    }
};
```

<br/>

#### Java

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode result = new ListNode(0, head);
        ListNode previous = result;
        while (previous.next != null && previous.next.next != null) {
            ListNode temp = previous.next.next;
            previous.next.next = previous.next.next.next;
            temp.next = previous.next;
            previous.next = temp;
            previous = previous.next.next;
        }
        return result.next;
    }
}
```

<br/>

#### JavaScript

```
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let result = new ListNode(0, head)
    let previous = result
    while (previous.next != null && previous.next.next != null) {
        let temp = previous.next.next
        previous.next.next = previous.next.next.next
        temp.next = previous.next
        previous.next = temp
        previous = previous.next.next
    }
    return result.next
};
```

<br/>

#### Go

```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    result := &ListNode{0, head};
    previous := result;
    for previous.Next != nil && previous.Next.Next != nil {
        temp := previous.Next.Next;
        previous.Next.Next = previous.Next.Next.Next;
        temp.Next = previous.Next;
        previous.Next = temp;
        previous = previous.Next.Next;
    }
    return result.Next;
}
```

<br/>

#### TypeScript

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
function swapPairs(head: ListNode | null): ListNode | null {
    let result: ListNode = new ListNode(0, head)
    let previous: ListNode = result
    while (previous.next != null && previous.next.next != null) {
        let temp: ListNode = previous.next.next
        previous.next.next = previous.next.next.next
        temp.next = previous.next
        previous.next = temp
        previous = previous.next.next
    }
    return result.next
};
```
