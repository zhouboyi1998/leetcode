<h1 style="text-align: center;"> <span style="color: #FFB822;">198. 打家劫舍</span> </h1>

### 🚀 LeetCode

<base target="_blank">

<span style="color: #FFB822;">**Medium**</span> [**https://leetcode.cn/problems/house-robber/**](https://leetcode.cn/problems/house-robber/)

---

### ❓ Description

<br/>

你是一个专业的小偷，计划偷窃沿街的房屋。

每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，

**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

给定一个代表每个房屋存放金额的非负整数数组，

计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。

<br/>

**示例 1：**

```
输入: [1, 2, 3, 1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1), 然后偷窃 3 号房屋 (金额 = 3)
     偷窃到的最高金额 = 1 + 3 = 4
```

**示例 2：**

```
输入: [2, 7, 9, 3, 1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9), 接着偷窃 5 号房屋 (金额 = 1)
     偷窃到的最高金额 = 2 + 9 + 1 = 12
```

<br/>

**提示：**

* `1 <= nums.length <= 100`
* `0 <= nums[i] <= 400`

---

### ❗ Solution

<br/>

#### idea

* 因为 `n >= 1`，所以不需要考虑房屋数为 `0` 的情况
    * 如果题目是 `n >= 0` 的情况，没有房屋可以偷
    * 多加一个 `if (n == 0) { return 0; }` 的特殊处理即可


* 当 `n == 1`，只有一间房屋可以偷，直接返回 `nums[0]`


* 当 `n == 2`，返回两间房屋中的金额较多者

<br/>

* 当 `n > 2`，该问题属于 **斐波那契数** 问题
* 新建一个长度为房屋数量的 <span style="color: #AF52DE;">**动态规划**</span> 数组 `dp`


* **动态规划** 的解法是从前往后遍历计算，逐步得出最终的结果
* **只需要考虑前面的结果，不需要考虑后面的情况**
* 遍历到第一间房屋时，只看到了一间房屋，最高金额自然就是这间房屋
    * `dp[0] = nums[0]`
* 遍历到第二间房屋时，最高金额是两间房屋中的金额较多者
    * `dp[1] = max(nums[0], nums[1])`
* 由此得出了两个初始值


* 从第三间房屋开始，由于不能连续偷两间房屋
* 所以最高金额要么是 **上上间房屋的最高金额** 加上 **自身的金额**
* 要么是 **上一间房屋的最高金额**
* **状态转移方程**：`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`

<br/>

#### Java

```
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
```
