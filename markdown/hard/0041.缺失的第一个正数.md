<h1 style="text-align: center;"> <span style="color: #FF2D55;">41. 缺失的第一个正数</span> </h1>

### 🚀 LeetCode

<base target="_blank">

<span style="color: #FF2D55;">**Hard**</span> [**https://leetcode.cn/problems/first-missing-positive/**](https://leetcode.cn/problems/first-missing-positive/)

---

### ❓ Description

<br/>

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

<br/>

**示例 1：**

```
输入: nums = [1, 2, 0]
输出: 3
```

**示例 2：**

```
输入: nums = [3, 4, -1, 1]
输出: 2
```

**示例 3：**

```
输入: nums = [7, 8, 9, 11, 12]
输出: 1
```

<br/>

**提示：**

* `1 <= nums.length <= 5 * 10^5`
* `-2^31 <= nums[i] <= 2^31 - 1`

---

### ❗ Solution

<br/>

#### idea

* 要求 **时间复杂度** 为 `O(n)`，解题过程中不可以使用排序
    * 排序算法的 **最差时间复杂度** 不可能是 `O(n)`
* 要求 **空间复杂度** 为 `O(1)`，解题过程中不可以使用额外的数组或容器
* 因此需要使用 **原地哈希** 的解题思路

<br/>

* 对于一个长度为 `n` 的数组，最小正数只能出现在 `[1, n + 1]` 中
* 如果 `[1, n]` 都出现在数组中，那么最小正数为 `n + 1`
* 否则最小正数在 `[1, n]` 中

<br/>

* 第一个循环，先将所有负数置为 `n + 1`
* 因为后续 **原地哈希** 会使用到负数，所以要先将原来的负数排除，以免影响后续操作

<br/>

* 第二个循环，进行 **原地哈希**
* 获取每一个 **元素的绝对值** `x`，如果 `x` 小于 `n + 1`
* 那么就将数组下标为 `x - 1` 位置上的 **另一个元素的值** 置为负数
    * 前面先将原来的负数排除、获取元素时获取绝对值
    * 也是因为这一步操作会将 **别的元素** 置为负数
    * 例如一个 `[3, 4, 1, 6]` 的数组
    * 遍历到数组下标 `0` 时，元素 `3` 会将数组下标为 `2` 的元素 `1` 置为负数
    * 但是当遍历到数组下标 `2` 的时候，需要的是元素原来正数的值 `1`，而不是 `-1`
    * 所以先取绝对值 `1`，然后将数组下标为 `0` 的元素 `3` 置为负数

<br/>

* 第三个循环，遍历数组找到第一个 **元素为正数** 的 **下标** `i`，`i + 1` 就是需要的结果
    * 因为在第二个循环中，每一个 **元素的绝对值** `x` 都会将数组下标为 `x - 1` 的 **另一个元素的值** 置为负数
    * 所以只要一个正数 `x` 出现过，数组下标 `x - 1` 上的元素就肯定是负数
    * 反过来，数组下标 `i` 上的元素是正数，说明正数 `i + 1` 没有出现过
* 如果遍历完数组都没有找到结果，说明正数 `[1, n]` 都出现在数组中，那么结果是数组长度加一

<br/>

#### Java

```
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0) {
                nums[i] = n + 1;
            }
        }
        for (int i = 0; i < n; i++) {
			int x = Math.abs(nums[i]);
            if (x <= n) {
                nums[x - 1] = -Math.abs(nums[x - 1]);
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```
